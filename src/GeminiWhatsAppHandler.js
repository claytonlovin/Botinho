const { GoogleGenerativeAI } = require("@google/generative-ai");
const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

dotenv.config();

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

if (!GEMINI_API_KEY) {
  console.error("‚ùå GEMINI_API_KEY n√£o encontrada no arquivo .env");
  process.exit(1);
}

const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

class GeminiWhatsAppHandler {
  constructor() {
    this.model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    this.conversationHistory = new Map(); // Armazena hist√≥rico por n√∫mero
    this.assessmentState = new Map(); // Estado da avalia√ß√£o por usu√°rio
    this.assessmentResults = new Map(); // Resultados da avalia√ß√£o
    this.quotaExceeded = false; // Flag para controlar quota
    this.lastQuotaCheck = 0; // Timestamp da √∫ltima verifica√ß√£o
    
    // Defini√ß√£o das perguntas da avalia√ß√£o
    this.assessmentQuestions = [
      {
        id: 1,
        type: 'text',
        question: 'Hello, my name is Ellen IA. Please introduce yourself in English.',
        instruction: 'Responda em forma de texto'
      },
      {
        id: 2,
        type: 'text',
        question: 'Perfect! What is your profession?',
        instruction: 'Responda em forma de texto'
      },
      {
        id: 3,
        type: 'audio',
        question: 'What is your biggest dream?',
        instruction: 'Responda em √°udio - Grave √°udio aqui no WhatsApp'
      },
      {
        id: 4,
        type: 'audio',
        question: 'What is your goal with English?',
        instruction: 'Responda em √°udio - Grave √°udio aqui no WhatsApp'
      },
      {
        id: 5,
        type: 'audio',
        question: 'Muito bem. Agora grave um √°udio, repetindo a seguinte frase:\n\n"English is one of the most widely spoken languages in the world. I\'m looking forward to starting my course soon."',
        instruction: 'Grave o √°udio repetindo a frase exatamente como mostrada'
      }
    ];
    
    // Timeout para respostas (5 minutos)
    this.responseTimeout = 5 * 60 * 1000;
  }

  // Verifica se a quota da API est√° dispon√≠vel
  checkQuotaStatus() {
    const now = Date.now();
    
    // Se quota foi excedida h√° menos de 1 hora, n√£o tenta novamente
    if (this.quotaExceeded && (now - this.lastQuotaCheck) < 3600000) {
      return false;
    }
    
    // Reset quota status se passou tempo suficiente
    if (this.quotaExceeded && (now - this.lastQuotaCheck) >= 3600000) {
      this.quotaExceeded = false;
      console.log('üîÑ Resetando status de quota - tentando novamente');
    }
    
    return !this.quotaExceeded;
  }

  // Marca quota como excedida
  markQuotaExceeded() {
    this.quotaExceeded = true;
    this.lastQuotaCheck = Date.now();
    console.log('üö´ Quota marcada como excedida');
  }

  // Fun√ß√£o para aguardar com delay
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Fun√ß√£o para converter arquivo de √°udio para base64
  audioToBase64(filePath) {
    try {
      const audioFile = fs.readFileSync(filePath);
      return audioFile.toString('base64');
    } catch (error) {
      throw new Error(`Erro ao ler arquivo de √°udio: ${error.message}`);
    }
  }

  // Fun√ß√£o para determinar MIME type
  getMimeType(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes = {
      '.mp3': 'audio/mp3',
      '.wav': 'audio/wav',
      '.m4a': 'audio/mp4',
      '.aac': 'audio/aac',
      '.ogg': 'audio/ogg',
      '.flac': 'audio/flac'
    };
    return mimeTypes[ext] || 'audio/ogg';
  }

  // Inicia uma nova avalia√ß√£o
  startAssessment(numero) {
    const assessmentData = {
      currentQuestion: 1,
      startTime: Date.now(),
      lastActivity: Date.now(),
      answers: [],
      isActive: true,
      completed: false
    };
    
    this.assessmentState.set(numero, assessmentData);
    this.clearHistory(numero);
    
    console.log(`üéØ Iniciando avalia√ß√£o para usu√°rio ${numero}`);
    return this.getCurrentQuestion(numero);
  }

  // Obt√©m a pergunta atual formatada
  getCurrentQuestion(numero) {
    const state = this.assessmentState.get(numero);
    if (!state || !state.isActive) {
      return this.startAssessment(numero);
    }

    const questionData = this.assessmentQuestions[state.currentQuestion - 1];
    if (!questionData) {
      return this.finishAssessment(numero);
    }

    const questionText = `üìù *Pergunta ${questionData.id}/5* - N√≠vel: Level\n\n` +
                        `${questionData.question}\n\n` +
                        `*${questionData.instruction}*`;

    return questionText;
  }

  // Processa resposta da avalia√ß√£o
  async processAssessmentResponse(numero, message, isAudio = false) {
    const state = this.assessmentState.get(numero);
    if (!state || !state.isActive) {
      return "ü§ñ Avalia√ß√£o n√£o iniciada. Digite 'iniciar' para come√ßar.";
    }

    // Verifica quota antes de processar
    if (!this.checkQuotaStatus()) {
      state.isActive = false; // Pausa avalia√ß√£o
      return "üö´ *Estamos processando muita informa√ß√£o*\n\n" +
             "Atingimos o limite de solicita√ß√µes por minutos. Sua avalia√ß√£o ficar√° pausada.\n\n" +
             "‚è∞ Tente novamente em algumas horas ou amanh√£.\n" +
             "Digite *iniciar* para continuar quando dispon√≠vel!";
    }

    // Verifica timeout
    if (Date.now() - state.lastActivity > this.responseTimeout) {
      return this.timeoutAssessment(numero);
    }

    const currentQuestion = this.assessmentQuestions[state.currentQuestion - 1];
    
    // Verifica se o tipo de resposta est√° correto
    if (currentQuestion.type === 'audio' && !isAudio) {
      return `‚ö†Ô∏è Esta pergunta precisa ser respondida em *√°udio*. ${currentQuestion.instruction}`;
    }
    
    if (currentQuestion.type === 'text' && isAudio) {
      return `‚ö†Ô∏è Esta pergunta precisa ser respondida em *texto*. ${currentQuestion.instruction}`;
    }

    // Processa a resposta
    let processedAnswer = '';
    let score = 0;

    try {
      if (isAudio) {
        // Avalia resposta de √°udio
        const evaluation = await this.evaluateAudioResponse(message, currentQuestion);
        processedAnswer = evaluation.transcription;
        score = evaluation.score;
      } else {
        // Avalia resposta de texto
        const evaluation = await this.evaluateTextResponse(message, currentQuestion);
        processedAnswer = evaluation.answer;
        score = evaluation.score;
      }

      // Armazena a resposta
      state.answers.push({
        questionId: currentQuestion.id,
        question: currentQuestion.question,
        answer: processedAnswer,
        type: currentQuestion.type,
        score: score,
        timestamp: Date.now()
      });

      // Atualiza estado
      state.lastActivity = Date.now();
      state.currentQuestion++;

      // Verifica se terminou
      if (state.currentQuestion > this.assessmentQuestions.length) {
        return this.finishAssessment(numero);
      }

      // Vai para pr√≥xima pergunta
      const nextQuestion = this.getCurrentQuestion(numero);
      return `‚úÖ Resposta registrada!\n\n${nextQuestion}`;

    } catch (error) {
      console.error('‚ùå Erro ao processar resposta:', error.message);
      
      // Se erro de quota, marca como excedida
      if (error.message.includes('quota') || error.message.includes('429')) {
        this.markQuotaExceeded();
        state.isActive = false;
        return "ü•π *Estamos processando muita informa√ß√£o*\n\n" +
               "Atingimos o limite de solicita√ß√µes por minutos. Sua avalia√ß√£o ficar√° pausada.\n\n" +
               "‚è∞ Tente novamente em algumas horas ou amanh√£.\n";
      }

      return "ü§ñ Erro ao processar sua resposta. Pode tentar novamente?";
    }
  }

  // Avalia resposta de texto
  async evaluateTextResponse(text, questionData) {
    const prompt = `
      Avalie esta resposta em ingl√™s para a pergunta: "${questionData.question}"
      
      Resposta do aluno: "${text}"
      
      Crit√©rios de avalia√ß√£o:
      - Gram√°tica (0-25 pontos)
      - Vocabul√°rio (0-25 pontos)
      - Flu√™ncia/Naturalidade (0-25 pontos)
      - Relev√¢ncia √† pergunta (0-25 pontos)
      
      Retorne apenas um JSON no formato:
      {
        "answer": "resposta_do_aluno",
        "score": nota_total_0_a_100,
        "feedback": "feedback_breve"
      }
    `;

    const result = await this.model.generateContent(prompt);
    const response = await result.response;
    
    try {
      const evaluation = JSON.parse(response.text());
      return evaluation;
    } catch (error) {
      // Fallback se n√£o conseguir parsear JSON
      return {
        answer: text,
        score: 70, // Pontua√ß√£o m√©dia como fallback
        feedback: "Resposta processada"
      };
    }
  }

  // Avalia resposta de √°udio
  async evaluateAudioResponse(audioData, questionData) {
    // Se audioData √© um caminho de arquivo, processa normalmente
    if (audioData.includes('/') || audioData.includes('temp_audio_') || audioData.includes('.ogg')) {
      const prompt = `
        Transcreva este √°udio em ingl√™s e avalie a resposta para: "${questionData.question}"
        
        Crit√©rios de avalia√ß√£o:
        - Pron√∫ncia (0-25 pontos)
        - Gram√°tica (0-25 pontos)
        - Vocabul√°rio (0-25 pontos)
        - Flu√™ncia (0-25 pontos)
        
        Retorne apenas um JSON no formato:
        {
          "transcription": "transcri√ß√£o_do_√°udio",
          "score": nota_total_0_a_100,
          "feedback": "feedback_sobre_pron√∫ncia_e_conte√∫do"
        }
      `;

      const audioBase64 = this.audioToBase64(audioData);
      const mimeType = this.getMimeType(audioData);
      
      const result = await this.model.generateContent([
        {
          inlineData: {
            data: audioBase64,
            mimeType: mimeType
          }
        },
        prompt
      ]);

      const response = await result.response;
      
      try {
        const evaluation = JSON.parse(response.text());
        return evaluation;
      } catch (error) {
        return {
          transcription: "√Åudio processado",
          score: 70,
          feedback: "√Åudio analisado"
        };
      }
    } 
    
    // Se audioData √© texto (transcri√ß√£o j√° feita), avalia como texto de √°udio
    else {
      console.log(`üé§ Avaliando transcri√ß√£o de √°udio: "${audioData}"`);
      
      const prompt = `
        Avalie esta resposta falada (j√° transcrita) em ingl√™s para: "${questionData.question}"
        
        Transcri√ß√£o: "${audioData}"
        
        Crit√©rios de avalia√ß√£o para resposta falada:
        - Gram√°tica (0-25 pontos)
        - Vocabul√°rio (0-25 pontos)
        - Flu√™ncia/Naturalidade (0-25 pontos)
        - Relev√¢ncia √† pergunta (0-25 pontos)
        
        Nota: Esta √© uma transcri√ß√£o de √°udio, ent√£o avalie considerando linguagem falada.
        
        Retorne apenas um JSON no formato:
        {
          "transcription": "transcri√ß√£o_fornecida",
          "score": nota_total_0_a_100,
          "feedback": "feedback_sobre_conte√∫do_falado"
        }
      `;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      
      try {
        const evaluation = JSON.parse(response.text());
        // Garante que a transcri√ß√£o seja preservada
        evaluation.transcription = audioData;
        return evaluation;
      } catch (error) {
        return {
          transcription: audioData,
          score: 70,
          feedback: "Resposta falada processada"
        };
      }
    }
  }

  // Finaliza avalia√ß√£o
  finishAssessment(numero) {
    const state = this.assessmentState.get(numero);
    if (!state) return "ü§ñ Nenhuma avalia√ß√£o em andamento.";

    state.isActive = false;
    state.completed = true;
    state.endTime = Date.now();

    // Calcula pontua√ß√£o final
    const totalScore = state.answers.reduce((sum, answer) => sum + answer.score, 0);
    const averageScore = Math.round(totalScore / state.answers.length);

    // Armazena resultado final
    const finalResult = {
      userId: numero,
      startTime: state.startTime,
      endTime: state.endTime,
      duration: state.endTime - state.startTime,
      answers: state.answers,
      totalScore: totalScore,
      averageScore: averageScore,
      level: this.getLevel(averageScore)
    };

    this.assessmentResults.set(numero, finalResult);

    console.log(`‚úÖ Avalia√ß√£o finalizada para ${numero} - Pontua√ß√£o: ${averageScore}`);

    return `üéâ *Avalia√ß√£o Conclu√≠da!*\n\n` +
           `üìä *Sua pontua√ß√£o final: ${averageScore}/100*\n` +
           `üìà *N√≠vel estimado: ${finalResult.level}*\n\n` +
           `Obrigada por participar da avalia√ß√£o! ` +
           `Em breve voc√™ receber√° mais informa√ß√µes sobre o curso.\n\n` +
           `üëã Tenha um √≥timo dia!`;
  }

  // Timeout da avalia√ß√£o
  timeoutAssessment(numero) {
    const state = this.assessmentState.get(numero);
    if (state) {
      state.isActive = false;
      console.log(`‚è±Ô∏è Timeout da avalia√ß√£o para ${numero}`);
    }

    return `‚è∞ *Tempo esgotado!*\n\n` +
           `A avalia√ß√£o foi finalizada por falta de resposta.\n` +
           `Digite 'iniciar' se quiser tentar novamente.\n\n` +
           `Obrigada!`;
  }

  // Determina n√≠vel baseado na pontua√ß√£o
  getLevel(score) {
    if (score >= 90) return "Advanced";
    if (score >= 75) return "Upper-Intermediate";
    if (score >= 60) return "Intermediate";
    if (score >= 45) return "Pre-Intermediate";
    if (score >= 30) return "Elementary";
    return "Beginner";
  }

  // Fun√ß√£o principal para processar mensagens do WhatsApp
  async processWhatsAppMessage(message, client) {
    try {
      const numero = message.from;
      const isGrupo = message.isGroupMsg || message.from.endsWith('@g.us');
      
      // Ignora grupos para avalia√ß√£o
      if (isGrupo) {
        return await this.processGroupMention(message.body || "");
      }

      console.log(`üì± Processando mensagem de ${numero}`);

      // Verifica comandos especiais
      const text = (message.body || "").toLowerCase().trim();
      if (text === 'iniciar' || text === 'start' || text === 'come√ßar') {
        return this.startAssessment(numero);
      }

      if (text === 'parar' || text === 'stop' || text === 'cancelar') {
        this.assessmentState.delete(numero);
        return "üõë Avalia√ß√£o cancelada. Digite 'iniciar' para come√ßar novamente.";
      }

      // Verifica se h√° avalia√ß√£o ativa
      const state = this.assessmentState.get(numero);
      if (!state || !state.isActive) {
        return `üëã Ol√°! Sou a Ellen IA.\n\n` +
               `Estou aqui para fazer uma avalia√ß√£o do seu n√≠vel de ingl√™s.\n` +
               `S√£o apenas 5 perguntas r√°pidas! üéØ\n\n` +
               `Digite *iniciar* Para come√ßar a avalia√ß√£o.`;
      }

      // Processa √°udio
      if (message.hasMedia && message.type === 'ptt') {
        console.log('üé§ Processando resposta em √°udio...');
        
        const media = await message.downloadMedia();
        const tempFileName = `temp_audio_${Date.now()}.ogg`;
        const tempFilePath = path.join(process.cwd(), tempFileName);
        
        const audioBuffer = Buffer.from(media.data, 'base64');
        fs.writeFileSync(tempFilePath, audioBuffer);
        
        try {
          return await this.processAssessmentResponse(numero, tempFilePath, true);
        } finally {
          if (fs.existsSync(tempFilePath)) {
            fs.unlinkSync(tempFilePath);
          }
        }
      }
      
      // Processa texto
      else if (message.body && message.body.trim()) {
        console.log('üí¨ Processando resposta em texto...');
        return await this.processAssessmentResponse(numero, message.body.trim(), false);
      }
      
      // Outros tipos de m√≠dia
      else if (message.hasMedia) {
        return "ü§ñ Para a avalia√ß√£o, preciso apenas de respostas em texto ou √°udio. Pode tentar novamente?";
      }
      
      return "ü§ñ N√£o consegui entender. Pode responder √† pergunta atual?";
      
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error.message);
      
      if (error.message.includes('quota') || error.message.includes('429')) {
        return "ü§ñ Desculpe, estou com limite de uso da API no momento. Tente novamente em alguns minutos! üòÖ";
      }
      
      return "ü§ñ Ops! Tive um problema t√©cnico. Pode tentar novamente?";
    }
  }

  // Fun√ß√£o para obter resultados da avalia√ß√£o
  getAssessmentResult(numero) {
    return this.assessmentResults.get(numero);
  }

  // Fun√ß√£o para listar todas as avalia√ß√µes
  getAllAssessmentResults() {
    return Array.from(this.assessmentResults.values());
  }

  // Atualiza hist√≥rico da conversa
  updateHistory(numero, role, content) {
    if (!this.conversationHistory.has(numero)) {
      this.conversationHistory.set(numero, []);
    }
    
    const history = this.conversationHistory.get(numero);
    history.push({ role, content, timestamp: Date.now() });
    
    // Mant√©m apenas √∫ltimas 20 intera√ß√µes para n√£o sobrecarregar
    if (history.length > 40) {
      history.splice(0, history.length - 40);
    }
    
    this.conversationHistory.set(numero, history);
  }

  // Limpa hist√≥rico de um usu√°rio
  clearHistory(numero) {
    this.conversationHistory.delete(numero);
  }

  // Fun√ß√£o para resposta simples em grupos (mantida como estava)
  async processGroupMention(entrada) {
    try {
      const input = entrada.toLowerCase().trim();
      const textoLimpo = input.replace(/@\w+/g, '').trim();
      
      if (textoLimpo.length < 10) {
        const respostasRapidas = {
          'oi': 'üëã Ol√°! Me mande uma mensagem privada para fazer sua avalia√ß√£o de ingl√™s!',
          'ol√°': 'üëã Oi! Me mande uma mensagem privada para come√ßar sua avalia√ß√£o!',
          'hello': 'üëã Hello! Send me a private message to start your English assessment!',
          'ajuda': 'ü§ñ Estou aqui para avaliar seu ingl√™s! Me mande uma mensagem privada.',
          'obrigado': 'üòä De nada! Sempre √†s ordens!',
          'thanks': 'üòä You\'re welcome!'
        };
        
        for (const [palavra, resposta] of Object.entries(respostasRapidas)) {
          if (textoLimpo.includes(palavra)) {
            return resposta;
          }
        }
      }
      
      return 'ü§ñ Oi! Me mande uma mensagem privada para fazer sua avalia√ß√£o de ingl√™s! üòä';
      
    } catch (error) {
      console.error('‚ùå Erro na resposta de grupo:', error.message);
      return 'ü§ñ Oi! Me mande uma mensagem privada para conversarmos melhor! üòä';
    }
  }

  // M√©todo espec√≠fico para processar √°udios via SessaoUsuario
  async processAudioMessage(numero, audioData) {
    try {
      console.log(`üé§ ProcessAudioMessage chamado para ${numero}`);
      
      // Verifica se h√° avalia√ß√£o ativa
      const state = this.assessmentState.get(numero);
      
      if (!state || !state.isActive) {
        return `üëã Ol√°! Sou a Ellen IA.\n\n` +
               `Estou aqui para fazer uma avalia√ß√£o do seu n√≠vel de ingl√™s.\n` +
               `S√£o apenas 5 perguntas r√°pidas! üéØ\n\n` +
               `Digite *iniciar* para come√ßar a avalia√ß√£o.`;
      }

      // Se h√° avalia√ß√£o ativa, processa como √°udio
      console.log(`üé§ Processando √°udio para pergunta ${state.currentQuestion}`);
      return await this.processAssessmentResponse(numero, audioData, true);
      
    } catch (error) {
      console.error('‚ùå Erro no processAudioMessage:', error.message);
      return "ü§ñ Erro ao processar seu √°udio. Pode tentar novamente?";
    }
  }

  // M√©todo processPrompt para compatibilidade com SessaoUsuario
  async processPrompt(numero, entrada, messageType = 'text') {
    try {
      console.log(`üéØ ProcessPrompt chamado para ${numero} com entrada: "${entrada}" - Tipo: ${messageType}`);
      
      // Verifica comandos especiais primeiro (expandido)
      const text = entrada.toLowerCase().trim();
      
      // Comandos para iniciar
      if (text === 'iniciar' || text === 'start' || text === 'come√ßar') {
        return this.startAssessment(numero);
      }

      // Comandos para parar/sair/voltar
      if (text === 'parar' || text === 'stop' || text === 'cancelar' || 
          text === 'sair' || text === 'exit' || text === 'quit' ||
          text === 'voltar' || text === 'volta' || text === 'back') {
        this.assessmentState.delete(numero);
        this.clearHistory(numero);
        return "üõë Avalia√ß√£o cancelada.\n\n" +
               "Digite *iniciar* para come√ßar uma nova avalia√ß√£o quando quiser.\n\n" +
               "üëã At√© mais!";
      }

      // Comandos informativos (sem usar API)
      if (text === 'ajuda' || text === 'help') {
        return "ü§ñ *Comandos dispon√≠veis:*\n\n" +
               "‚Ä¢ *iniciar* - Come√ßar avalia√ß√£o\n" +
               "‚Ä¢ *parar* - Cancelar avalia√ß√£o\n" +
               "‚Ä¢ *status* - Ver progresso\n" +
               "‚Ä¢ *resultado* - Ver resultado final\n\n" +
               "üìù Durante a avalia√ß√£o, responda as perguntas em ingl√™s!";
      }

      if (text === 'status') {
        const state = this.assessmentState.get(numero);
        if (state && state.isActive) {
          return `üìä *Status da Avalia√ß√£o*\n\n` +
                 `üìù Pergunta atual: ${state.currentQuestion}/5\n` +
                 `‚è∞ Iniciada: ${new Date(state.startTime).toLocaleTimeString()}\n\n` +
                 `Continue respondendo √† pergunta atual!`;
        }
        return "üìä Nenhuma avalia√ß√£o ativa.\n\nDigite *iniciar* para come√ßar!";
      }

      if (text === 'resultado' || text === 'result') {
        const result = this.getAssessmentResult(numero);
        if (result) {
          return `üéØ *Seu Resultado Final*\n\n` +
                 `üìä Pontua√ß√£o: ${result.averageScore}/100\n` +
                 `üìà N√≠vel: ${result.level}\n` +
                 `‚è±Ô∏è Dura√ß√£o: ${Math.round(result.duration / 1000 / 60)} minutos\n\n` +
                 `üéâ Parab√©ns por completar a avalia√ß√£o!`;
        }
        return "üìä Nenhum resultado encontrado.\n\nComplete uma avalia√ß√£o primeiro!";
      }

      // Verifica se h√° avalia√ß√£o ativa
      const state = this.assessmentState.get(numero);
      
      if (state && state.isActive) {
        // Detec√ß√£o inteligente de √°udio baseada no conte√∫do da entrada
        const isAudio = messageType === 'audio' || 
                       entrada.includes('[Enviou √°udio]') || 
                       entrada.includes('temp_audio_') ||
                       entrada.startsWith('audio:') ||
                       // Se a pergunta atual requer √°udio e a resposta parece ser transcri√ß√£o
                       (this.assessmentQuestions[state.currentQuestion - 1]?.type === 'audio' && 
                        (entrada.length > 20 || entrada.includes('√°udio') || entrada.includes('audio')));
        
        console.log(`üìù Avalia√ß√£o ativa - processando resposta para pergunta ${state.currentQuestion} - isAudio: ${isAudio}`);
        
        // Se a pergunta requer √°udio mas chegou como texto, assume que √© transcri√ß√£o de √°udio
        const currentQuestion = this.assessmentQuestions[state.currentQuestion - 1];
        if (currentQuestion?.type === 'audio' && !isAudio) {
          console.log(`üé§ Pergunta requer √°udio, mas chegou como texto - assumindo que √© transcri√ß√£o`);
          return await this.processAssessmentResponse(numero, entrada, true);
        }
        
        return await this.processAssessmentResponse(numero, entrada, isAudio);
      }

      // Se n√£o h√° avalia√ß√£o ativa, FOR√áA iniciar uma nova avalia√ß√£o
      console.log(`üéØ Nenhuma avalia√ß√£o ativa - iniciando nova avalia√ß√£o para ${numero}`);
      return this.startAssessment(numero);
      
    } catch (error) {
      console.error('‚ùå Erro no processPrompt:', error.message);
      
      // Tratamento espec√≠fico para erro de quota
      if (error.message.includes('quota') || error.message.includes('429') || 
          error.message.includes('Too Many Requests')) {
        console.log('üö´ Quota da API excedida - pausando avalia√ß√£o');
        
        // Pausa a avalia√ß√£o atual
        const state = this.assessmentState.get(numero);
        if (state) {
          state.isActive = false;
        }
        
        return "üö´ *Limite da API atingido!*\n\n" +
               "Infelizmente atingimos o limite di√°rio de uso da API do Gemini (50 requests/dia no plano gratuito).\n\n" +
               "‚è∞ *O que fazer:*\n" +
               "‚Ä¢ Aguarde algumas horas e tente novamente\n" +
               "‚Ä¢ Ou tente amanh√£\n" +
               "‚Ä¢ Sua avalia√ß√£o ficar√° salva para continuar depois\n\n" +
               "Digite *iniciar* mais tarde para continuar!\n\n" +
               "üòÖ Desculpe pelo inconveniente!";
      }
      
      return "ü§ñ Ops! Tive um problema t√©cnico. Pode tentar novamente em alguns minutos?";
    }
  }

  // M√©todo principal de processamento (para compatibilidade com c√≥digo existente)
  async processMessage(message, client) {
    return await this.processWhatsAppMessage(message, client);
  }

  // M√©todo alternativo de processamento
  async handleMessage(message, client) {
    return await this.processWhatsAppMessage(message, client);
  }

  // M√©todo para processar comando espec√≠fico
  async processCommand(command, numero, args = []) {
    switch (command.toLowerCase()) {
      case 'iniciar':
      case 'start':
      case 'come√ßar':
        return this.startAssessment(numero);
      
      case 'parar':
      case 'stop':
      case 'cancelar':
        this.assessmentState.delete(numero);
        return "üõë Avalia√ß√£o cancelada. Digite 'iniciar' para come√ßar novamente.";
      
      case 'status':
        const state = this.assessmentState.get(numero);
        if (state && state.isActive) {
          return `üìä Avalia√ß√£o em andamento - Pergunta ${state.currentQuestion}/5`;
        }
        return "üìä Nenhuma avalia√ß√£o ativa.";
      
      case 'resultado':
      case 'result':
        const result = this.getAssessmentResult(numero);
        if (result) {
          return `üéØ Seu resultado: ${result.averageScore}/100 - N√≠vel: ${result.level}`;
        }
        return "üìä Nenhum resultado encontrado.";
      
      default:
        return "ü§ñ Comando n√£o reconhecido. Use: iniciar, parar, status, resultado";
    }
  }

  // Testa conex√£o com API
  async testConnection() {
    try {
      console.log("üîç Testando conex√£o com Gemini API...");
      
      const result = await this.model.generateContent("Responda apenas: API funcionando");
      const response = await result.response;
      
      console.log("‚úÖ API conectada com sucesso!");
      console.log("üìä Resposta de teste:", response.text());
      return true;
      
    } catch (error) {
      console.error("‚ùå Erro na conex√£o:", error.message);
      return false;
    }
  }
}

module.exports = { GeminiWhatsAppHandler };